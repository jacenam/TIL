# 비교 연산자

비교(Comparison) 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다. 주로 `if`문이나 `for`문과 같은 제어문의 조건식에서 사용한다

### 목차

- [1 동등/일치 비교 연산자](#1-동등/일치-비교-연산자)
  - [1-1 == 동등 비교 연산자(느슨한 비교)](#1-1-==-동등-비교-연산자(느슨한-비교))
  - [1-2 === 일치 비교 연산자(엄격한 비교)](#1-2-===-일치-비교-연산자(엄격한-비교))
  - [1-3 != 부동등 비교 연산자와 !== 불일치 비교 연산자**](#1-3-!=-부동등-비교-연산자와-!==-불일치-비교-연산자)
- [2 대소 관계 비교 연산자](#2-대소-관계-비교-연산자)

***

<br>

## 1 동등/일치 비교 연산자

| 비교 연산자 | 의미                   | 사례    | 설명                       | 부수 효과 |
| ----------- | ---------------------- | ------- | -------------------------- | --------- |
| ==          | 동등 비교(느슨한 비교) | x == y  | x와 y의 값이 같다          | 없음      |
| ===         | 일치 비교(엄격한 비교) | x === y | x와 y의 값과 타입이 같다   | 없음      |
| !=          | 부동등 비교            | x != y  | x와 y의 값이 다르다        | 없음      |
| !==         | 불일치 비교            | x !== y | x와 y의 값과 다입이 다르다 | 없음      |

동등 비교(느슨한 비교, loose equality) 연산자와 일치 비교(엄격한 비교, strict equality) 연산자는 좌항과 우항의 피연산자를 비교하는 엄격성의 정도가 다르다

### 1-1 == 동등 비교 연산자(느슨한 비교)

```jsx
// 좌항과 우항 피연산자의 값과 타입 모두 같을 때
0 == 0; // → true

// 좌항과 우항 피연산자의 타입은 다르지만 암묵적 변환을 통해 타입을 일치시키면 값이 같을 때
0 == '0'; // → true

if ( 1 == '1' ) {
	console.log("1과 '1'은 동일하다"); // → 1과 '1'은 동일하다
} else {
	console.log("1과 '1'은 동일하지 않다");
}
```

좌항과 우항의 피연산자를 비교할 때 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다. 다른 타입을 가진 두 값이 같은지 비교하기 위해서는 타입 변환이 선행으로 이루어지는 것이다. 결과를 예측하기 어려워 코드 상에 실수가 발생할 수 있으니 일치 비교 `===` 연산자 쓰기를 권장한다

### 1-2 === 일치 비교 연산자(엄격한 비교)

```jsx
1 === 1; // → true 
1 === '1'; // → false

if ( 1 === '1') { 
	console.log("1과 '1'은 동일하다"); 
} else {
	console.log("1과 '1'은 동일하지 않다"); // → 1과 '1'은 동일하지 않다
}
```

좌항과 우항의 피연산자 타입도 같고 값도 같은 경우 `true`를 반환한다. 암묵적 타입 변환이 이루어지지 않은 채로 값을 비교하는 것이다. `==` 동등 비교 연산자에 비해 예측하기가 쉬우나 주의할 점들이 있다:

- **NaN** 
  JS 상에서 자기 자신과 일치하지 않는 유일한 값이다.

  ```javascript
  NaN === NaN; // → false
  ```

  따라서 보다 정확히 숫자가 `NaN`인지 판별하기 위해서는 빌트인 함수 `Number.isNaN`을 사용하는 것이 좋다. `Number.isNaN` 함수는 지정한 값이 `NaN`인지 확인하고 그 결과를 불리언 값으로 반환한다. 이에 대해서는 [**여기**]()를 참고하자

  ```javascript
  Number.isNaN(NaN); // → true
  Number.isNaN(10); // → false
  Number.isNaN(1 + undefined); // → true
  ```

- **숫자 타입 `0`**
  양의 `0`과 음의 `0` 일치 비교 및 동등 비교 결과 모두 `true`다

  ```javascript
  0 === -0; // → true
  0 == -0; // → true
  ```

  양의 `0`과 음의 `0` 일치 비교 및 동등 비교의 결과는 모두 `true`며, 동일한 값인 `NaN`과 `NaN`을 비교하면 다른 값이라 평가된다. ES6에서 도입된 `Object.is` 메서드는 다음과 같이보다 정확한 비교 결과를 반환한다. 이에 대해서는 [**여기**]()를 참고하자

  ```javascript
  Object.is(-0, 0); // → false
  Object.is(NaN, NaN); // → true
  ```

### 1-3 != 부동등 비교 연산자와 !== 불일치 비교 연산자

부동등 비교 연산자와 불일치 비교 연산자는 각각 `==` 동등 비교 연산자와 `===` 일치 비교 연산자의 반대되는 개념이다

```jsx
// 부동등 비교 연산자
5 != 8; // → true
5 != 5; // → false
5 != '5'; // → false

// 불일치 비교 연산자
5 !== 8; // → true
5 !== 5; // → false
5 !== '5'; // → true
```

<br>

## 2 대소 관계 비교 연산자

대소 관계 비교 연산자는 피연산자의 크기를 비교한 다음 **그 결과를 불리언 값으로 반환**한다

| 대소 관계 비교 연산자 | 사례   | 설명                  | 부수 효과 |
| --------------------- | ------ | --------------------- | --------- |
| >                     | x > y  | x가 y보다 크다        | 없음      |
| <                     | x < y  | x가 y보다 작다        | 없음      |
| >=                    | x >= y | x가 y보다 크거나 같다 | 없음      |
| <=                    | x <= y | x가 y보다 작거나 같다 | 없음      |

```jsx
5 > 0; // → true
5 < 5; // → false
5 >= 5; // → true
5 <= 5; // → true
```

<br>

***

### 참고

- [모던 자바스크립트 Deep Dive](http://www.yes24.com/Product/Goods/92742567)