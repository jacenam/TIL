# 논리 연산자

### 목차

- [1 논리 연산자란](#1-논리-연산자란)
- [2 논리합 연산자](#2-논리합-연산자)
  - [2-1 OR 연산자의 동작 방식](#2-1-OR-연산자의-동작-방식)
  - [2-2 OR 연산자와 타입 변환](#2-2-OR-연산자와-타입-변환)
  - [2-3 OR 연산자의 주의할 점](#2-3-OR-연산자의-주의할-점)
- [3 논리곱 연산자](#3-논리곱-연산자)
  - [3-1 AND 연산자의 동작 방식](#2-1-AND-연산자의-동작-방식)
  - [3-2 AND 연산자와 타입 변환](#3-2-AND-연산자와-타입-변환)
  - [3-3 AND 연산자의 주의할 점](#3-3-AND-연산자의-주의할-점)
- [4 부정 논리 연산자](#4-부정-논리-연산자)

***

<br>

## 1 논리 연산자란

논리(Logical) 연산자는 우항과 좌항의 피연산자를 논리적으로 따져 참과 거짓을 가리고 불리언 값 `true`와 `false`로 반환해 수행해야 될 연산을 처리한다

| 논리 연산자 | 의미        | 부수 효과 |
| ----------- | ----------- | --------- |
| `||`        | 논리합(OR)  | 없음      |
| `&&`        | 논리곱(AND) | 없음      |
| `!`         | 부정(NOT)   | 없음      |

<br>

## 2 논리합 연산자

논리 연산의 대상인 피연산자들이 평가되어 하나라도 그 결과 값이 참이라면 `true`에 해당하는 값을 반환하고, 그렇지 않을 시 `false`에 해당하는 값을 반환한다

```jsx
true || true; // → true
true || false; // → true
false || true; // → true
false || false; // → false
```

위 예제에서는 불리언 값 `true`와 `false` 논리 연산하는 것이기 때문에 `true`와 `false`에 해당하는 값은 `true`와 `false` 그 자체다

### 2-1 OR 연산자의 동작 방식

1. 표현식의 좌측부터 `true`에 해당하는 값을 찾아나간다
2. `true`에 해당하는 값을 찾은 경우, 연산 수행을 그 즉시 멈추고 바로 `true`에 해당하는 값을 반환한다
3. `true`에 해당하는 값이 마지막 피연산자까지 없다면 마지막 값을 반환한다

```jsx
true || true; // → true
true || false; // → true
false || true; // → true
false || false || true || false; // → true
false || '' || 1 || true; // → 1
false || false; // → false
```

### 2-2 OR 연산자와 타입 변환

OR 연산자는 피연산자가 모두 `false`일 때를 제외하고는 항상 `true`다

```jsx
false || '' || 1 || true; // → 1
```

빈 문자열(`’’`)은 불리언 타입으로 평가될 때 어째서 `false`로 반환되는 것일까? 그 이유에 대해서는 **[타입 변환과 단축 평가]()**를 참고하자

### 2-3 OR 연산자의 주의할 점

OR 연산자(뒤에 나올 AND 연산자도 동일) 사실 **피연산자 중 하나의 값만을 반환하는 것**이다. 즉, 불리언 값 이외의 값과 함께 사용하면 **불리언이 아닌 값도 반환할 수 있다**. 또한, 좌측부터 평가를 수행해 나가다가 평가를 멈추고 `true`와 `false` 값을 반환하는 시점을 기억하자

- **첫 번째 피연산자가 `true`인 경우**

  ```javascript
  'jace' || 'nam'; // → 'jace'
  3 || false; // → 3
  'jace' || null; // → 'jace'
  ```

- **피연산자 모두가 `false`인 경우**

  ```javascript
  null || false; // → false
  false || 0; // → 0
  null || undefined; // → undefined	
  null || undefined || ''; // → ''
  ```

OR 연산자는 좌측에서부터 차례대로 `true` 값을 찾아나간다. 차례대로 마지막까지 true 값을 찾아가는데도 `true` 값 없이 피연산자 모두가 `false`인 경우 가장 마지막 피연산자를 반환한다

빈 문자열(`’’`)과 마찬가지로 어째서 문자열(`’jace’`, `‘nam’`)은 참이며, `null`과 `undefined`는 거짓으로 평가되는 걸까? 이에 대해서도 **[타입 변환과 단축 평가]()**를 참고하자

<br>

## 3 논리곱 연산자

AND 연산자는 피연산자가 모두 참일 때만 `true`를 반환하며, 거짓이 하나라도 있다면 `false`를 반환한다

```jsx
true && true; // → true
true && false; // → false
false && true; // → false
false && false; // → false
```

### 3-1 AND 연산자의 동작 방식

1. OR 연산자와는 달리, 표현식의 좌측부터 `false`값을 찾아나간다
2. `false` 값을 찾은 경우, 연산 수행을 그 즉시 멈추고 `false`에 해당하는 값을 반환한다
3. `false` 값이 마지막 피연자까지 없다면 마지막 값을 반환한다

```jsx
true && true; // → true
true && false; // → false
false && true; // → false
false && false; // → false
true && true && false && true // → false
true && "231" && 0 && 300; // → 0
true && true && 1 && ' '; // → ' ' 
```

### 3.2 AND 연산자와 타입 변환

(OR 연산자와 동일하게) 피연산자가 불리언 타입이 아닐 경우 평가를 위해 불리언 타입으로 암묵적 타입 변환된다

```jsx
true && "231" && 0 && 300; // → *0*
```

문자열 `“231”`가 불리언 타입으로 평가될 때 어째서 `true`로 반환되는 것일까? 숫자 값 `1`과 문자열 값 `‘1’`(암묵적 타입 변환으로 숫자 값 `1`)이 `true`라고 하지 않았나? 그 이유에 대해서는 [**타입 변환과 단축 평가**](https://www.notion.so/d52133051411406f81e5f841bc5d7933)를 참고하자

### 3-3 AND 연산자의 주의할 점

OR 연산자와 마찬가지로, AND 연산자  또한 **피연산자 중 하나의 값만을 반환하는 것**이다. 즉, 불리언 값 이외의 값과 함께 사용하면 **불리언이 아닌 값도 반환할 수 있다**. 또한, 좌측부터 평가를 수행해 나가다가 평가를 멈추고 `true`와 `false` 값을 반환하는 시점을 기억하자

- **피연산자 모두가 `false`인 경우**

  ```javascript
  undefined && false && 0; // → undefined
  '' && false && null; // → ''
  ```

- **피연산자 모두가 `true`인 경우**

  ```javascript
  'jace' && 'nam' // → 'nam'
  true && 3 && ' '; // → ' '
  ```

OR 연산자와는 반대로, AND 연산자는 좌측에서부터 차례대로 `false` 값을 찾아나간다. 차례대로 마지막까지 `false` 값을 찾아가는데도 `false` 값 없이 피연산자 모두가 `true`인 경우 가장 마지막 피연산자를 반환한다

<br>

## 4 부정 논리 연산자

부정 논리 연산자(NOT, `!`)는 **피연산자 하나를** 불리언 타입으로 평가하고 그 결과 값 `true`와 `false`의 반대 값을 반환한다. 또한, 부정 논리 연산자는 **언제나 불리언 값을 반환**한다.

```jsx
!true; // → false
!false; // → true
```

단, 피연산자가 반드시 불리언 값일 필요는 없다. 피연산자가 불리언 타입이 아닐 경우 평가를 위해 불리언 타입으로 암묵적 타입 변환된다

> 부정 논리 연산자로 인한 암묵적 타입 변환의 과정에 대해서는 **[여기]()**를 참고하자

```jsx
!0; // → true
!' '; // → false
```

하나의 피연산자 이상을 부정 연산자로 연산하고자 한다면 식 전체를 괄호(`()`)로 감싸야 한다

```jsx
var a = 1; 
var b = 2;

!(a == b); // → true
```

만약 `!` 부정 논리 연산자를 두 번 연달아 사용한다면 평가 결과의 반대의 반대, 즉 정상적인 결과 값을 반환한다

```jsx
!!0; // → true
!!' '; // → false
```

부정 논리 연산자를 두번 연달아 사용하는 것은 피연산자를 [**불리언 타입으로 명시적 타입 변환**]()하기 위해 사용된다

<br>

***

### 참고

- [모던 자바스크립트 Deep Dive](http://www.yes24.com/Product/Goods/92742567)
- [JavaScript - 논리연산자(Logical Operator)에 대해 알아보자](https://velog.io/@surim014/웹을-움직이는-근육-JavaScript란-무엇인가-part-5-Logical-Operator)
- [[JS]잘못 알고 있었던 논리연산자](https://velog.io/@proshy/JS잘못-알고-있었던-논리연산자)