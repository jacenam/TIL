# 전역 변수의 문제점

앞서 [스코프](https://github.com/jacenam/WIL-archive/blob/main/Web%20Development/JS/JS%20Basics/Scope/scope.md)에 대한 내용 중 실무 프로그래밍에서 전역 변수의 사용을 지양한다고 했다. 전역 변수의 무분별한 사용은 프로그래밍상 의도치 않은 오류들을 야기할 수 있기 때문이다. 전역 변수의 문제점들을 상세히 다뤄보자

### 목차

- [1 변수의 생명 주기](#1-변수의-생명-주기)
  - [1-1 지역 변수의 생명 주기](#1-1-지역-변수의-생명-주기)
  - [1-2 전역 변수의 생명 주기](#1-2-전역-변수의-생명-주기)

- 

***

<br>

## 1 변수의 생명 주기

[변수와 메모리의 동작 방식](https://github.com/jacenam/WIL-archive/blob/main/Web%20Development/JS/JS%20Basics/variable.md#2-%EB%B3%80%EC%88%98%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC) 파트에서 언급했듯이, 변수는 '선언 - 할당'을 통해 메모리 공간을  확보하여 값을 할당한다. 만약 이렇게 확보된 메모리 공간에 변수가 계속해서 용량을 차지하고 있다면 프로그램의 효율이 떨어질 것이다. 따라서 변수에는 생성되고 소멸되는 생명 주기(Life Cycle)가 존재한다. 그러나 변수의 생명 주기는 변수가 선언된 위치(전역, 지역)에 따라 상이하게 된다

### 1-1 지역 변수의 생명 주기

불필요한 변수의 생성 및 유지는 그만큼의 메모리 공간을 차지하기 때문에 비효율적이다. 예를 들어 아래와 같이 1000줄이 넘는 프로그램이 있다고 가정해보자: 

```javascript
var a1 = 1;
var a2 = 2;
var a3 = 3; 
...;
...;
var a999 = 999;
var a1000 = 1000;
```

변수 `a1`에서 `a1000`은 전역(코드의 가장 바깥 영역)에서 선언되었기 때문에 위 프로그램이 종료될 때까지 변수들이 메모리의 일정 공간을 점유하고 소멸되지 않는다. 즉, 프로그램과 전역 변수는 생명 주기가 같다

하지만 지역(함수 내부)에서 선언된 변수는 함수가 호출되어 함수 내부 코드가 실행되었을 때만 생성되며 함수가 종료되면 소멸하여 메모리 측면에서 더욱 효율적이다. 함수 호출이 없다면 함수 내부의 변수 선언문 또한 실행되지 않기 때문이다

```javascript
function program1() {
  var a1 = 1;
  var a2 = 2;
  var a3 = 3;
  ...;
  ...;
  var a499 = 499;
  var a500 = 500;

  return a1 + a2 + a3 + ... + a499 + a500;
}


function program2() {
  var a501 = 501;
  ...;
  ...;
  var a1000 = 1000;
  
  return a501 + a502 + ... + a1000;
}

program1();
```

물론 지역 변수의 생명 주기가 함수의 생명 주기보다 오래 지속되는 경우도 있다. 지역 변수는 함수의 지역 스코프에 등록되는데 특정 상황에서 지역 변수의 메모리 공간을 계속해서 참조하고 있다면 함수가 종료되더라도 지역 변수가 생존하기도 한다. 함수가 종료되면 함수의 지역 스코프도 소멸하는 것이 일반적이지만, 스코프가 계속해서 참조되고 있다면 함수가 종료되더라도 스코프는 해제되지 않는 경우도 있기 때문이다. 이에 대해서는 [클로저]() 파트를 참고하자

### 1-2 전역 변수의 생명 주기

앞서 언급했듯이, 전역 변수는 전역 전체에서 유효하다. 따라서 함수와는 달리, 함수 호출과 같은 명시적인 실행 명령 없이 소스코드가 JS 엔진에 의해 해석되고 바로 실행된다. 또한, 함수와 같이 함수 몸체의 마지막 문, 반환문이라는 종료를 의미하는 코드가 없어 변수가 실행된 이후 프로그램이 종료되어야만 소멸된다

전역 변수가 선언되면 브라우저 환경에서는 `window`, node.js 환경에서는 `console`, `module`과 같은 `global`/전역 객체의 프로퍼티가 된다. 즉, 브라우저 환경에서 전역 변수는 브라우저의 웹페이지를 종료하기 전까지 생존한다. 그만큼 전역 변수의 생명 주기가 길다는 의미라고 이해하면 된다

> 전역 객체(Global Object)에 대한 내용은 현재로서 깊게 다루지 않을 것이다. JS에서는 모든 값(원시 타입과 객체 타입)이 객체의 형태로 저장되어 관리된다. 즉, 전역 변수 `x`, `y`는 브라우저 환경에서 아래와 같이 저장된다: 
>
> ```javascript
> // 만약 전역 변수를 선언하면
> var x = 1;
> var y = 2;
> 
> // 브라우저 환경에서는 window 객체(전역 객체)로 아래와 같이 등록된다
> window = {
>   x: 1,
>   y: 2,
> }
> ```
>
> 따라서 브라우저에서 `window` 객체의 프로퍼티로 변수 `x`와 `y`의 접근할 수 있다
>
> ```javascript
> // 프로퍼티 접근 연산자를 활용한 객체 값에 접근
> window.x; // → 1
> window.y; // → 2
> 
> // 여러가지 빌트인 객체를 통해 전역 변수에 접근도 가능하다
> alert(window.x); // (alert 팝업) → 1
> ```
>
> 전역 객체와 빌트인 객체에 대한 자세한 내용은 추후 [빌트인 객체]()에서 살펴보자





- 전역 변수
  - 긴 생명 주기 
  - 소멸하지 않는 만큼 메모리 리소스도 오랜 기간 소비
  - 전역 변수의 의도치 않은 상태 변경이 발생할 가능성이 높음
  - 스코프 체인 상에서 종점에 존재(JS 엔진이 변수를 검색할 때 전역 변수는 가장 마지막에 검색되므로 속도 차이가 발생)
  - 파일이 분리되어 있다해도 하나의 전역 스코프를 공유. 다른 파일 내에서 동일한 이름으로 지정된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 파일끼리 네임스페이스가 오염될 가능성이 큼

- 반면, 지역 변수는 
  - 짧은 생명 주기 
  - 메모리 리소스도 짧은 기간만 소비
  - 전역 변수보다 상태 변경에 의한 오류가 발생할 확률이 적음
  

따라서 반드시 전역 변수를 사용해야 하는 것이 아니라면 지역 변수를 사용해야 함

<br>

***
### 참고

- [모던 자바스크립트 Deep Dive](http://www.yes24.com/Product/Goods/92742567)
- [모던 JavaScript 튜토리얼 - 전역 객체](https://ko.javascript.info/global-object) 
- [전역 객체 `window`](https://opentutorials.org/course/1375/6633)
- [Oject Model](https://opentutorials.org/course/1375/6622)
- [전역 변수를 왜 지양해야 하는가](https://intzzzero.netlify.app/blog/no-more-global-variables)

