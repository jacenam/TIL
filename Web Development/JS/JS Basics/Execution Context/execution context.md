# 실행 컨텍스트

### 목차

- [1 실행 컨텍스트란](#1-실행-컨텍스트란)
  - [1-1 소스코드의 종류](#1-1-소스코드의-종류)
  - [1-2 소스코드의 평가와 실행](#1-2-소스코드의-평가와-실행)
  - [1-3 실행 컨텍스트의 역할](#1-3-실행-컨텍스트의-역할)
- [2 실행 컨텍스트 스택](#2-실행-컨텍스트-스택)
- [3 렉시컬 환경](#3-렉시컬-환경)
- [4 실행 컨텍스트의 생성과 식별자 검색 과정](#4-실행-컨텍스트의-생성과-식별자-검색-과정)
- [5 실행 컨텍스트와 블록 레벨 스코프](#5-실행-컨텍스트와-블록-레벨-스코프)

<br>

## 1 실행 컨텍스트란

실행 컨텍스트(Execution Context)는 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 관리한다.  JS의 동작 원리를 이해하는데 핵심 개념으로서, 추후 살펴볼 식별자 바인딩, 호이스팅 발생 이유, 클로저, 태스큐 큐, 이벤트 핸들러, 비동처 처리 등의 동작 원리와 개념들을 이해할 수 있다. 실행 컨텍스트에 대해 정리하기에 앞서 ECMAScript 사양을 살펴봐야 한다

### 1-1 소스코드의 종류

JS는 개발자가 컴퓨터에게 전달한 소스코드를 한 줄씩 실행하는 인터프리터 언어라고 했다. JS 명세인 ECMAScript 사양에 따르면 소스코드는 4가지 타입으로 구분된다. 아래 4가지 타입의 소스코드는 종류에 따라 실행 컨텍스트를 각각 다르게 생성하고 관리한다

<img src="https://github.com/jacenam/WIL-archive/assets/92138751/3e9ca6cf-ecb8-4e79-b730-99909c89313d" width="100%">

| 소스코드 타입            | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| 전역 코드(Global Code)   | 전역에 존재하는 소스코드. 단, 전역에서 정의된 함수, 클래스 등의 내부 코드들은 포함하지 않는다 |
| 함수 코드(Function Code) | 함수 내부에 존재하는 소스코드. 단, 함수 내부에 중첩된 함수(헬퍼 함수), 클래스 등의 내부 코드는 포함하지 않는다 |
| `eval` 코드(Eval Code)   | 빌트인 전역 `eval` 함수에 인수로 전달되어 실행되는 소스코드  |
| 모듈 코드(Module Code)   | 모듈 내부에 존재하는 소스코드. 단, 모듈 내부의 함수, 클랫 등의 내부 코드는 포함하지 않는다 |

- **전역 코드**

  코드의 가장 바깥 영역인 전역에서 `var` 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 코드라고 부른다. 이렇게 전역에서 선언된 전역 코드는 JS 엔진에 의해 평가되어 전역 실행 컨텍스트를 생성하게 되고, 이를 통해 전역 변수와 전역 함수를 전역 객체 `window`의 프로퍼티와 메서드로 바인딩한다

  ```javascript
  // 1 전역 코드(전역에서의 소스코드) 입력
  var variable = 1; 
  
  function func() {
    console.log("global method");
  }
  
  // 2 전역 실행 컨텍스트 생성
  
  // 3 전역 객체 window의 프로퍼티와 메서드로 바인딩
  console.log(window.variable); // → 1
  console.log(window.func); // → ƒ func() { console.log("global method") }
  ```

- **함수 코드**

  함수 몸체 내부에서 변수 혹은 중첩된 함수가 선언되어 [지역 스코프](https://github.com/jacenam/WIL-archive/blob/main/Web%20Development/JS/JS%20Basics/Scope/scope.md)를 갖게되는 코드를 함수 코드라고 부른다. 지역 변수 혹은 지역 함수가 선언되어 JS 엔진에 의해 평가되면 함수 실행 컨텍스트를 생성하게 된다. 함수 실행 컨텍스트는 지역 스코프를 생성하고 지역 변수, 매개변수, [`argments` 객체]()를 관리하게 된다. 또한 지역 스코프를 전역 스코프 체인의 일원으로 연결하는 기능도 실행한다

  ```javascript
  // 1 전역 함수 입력(전역 스코프는 갖지 않는다)
  function func() {
    
    // 2 지역 변수 및 지역 함수 선언문 호이스팅
    // 3 함수 실행 컨텍스트 생성
   
    // 지역 변수
    var outer = "outer";
    console.log(outer); // → global outer
   
    // 지역 함수
    function innerFunc() {
      var inner = "inner";
      console.log(outer, inner); // → global outer inner
    }
    innerFunc();
  }
  
  func();
  ```

- **`eval` 코드**

  > 앞서 [빌트인 전역 함수](https://github.com/jacenam/WIL-archive/blob/main/Web%20Development/JS/JS%20Basics/Data%20Type/built-in%20object.md#3-2-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EC%A0%84%EC%97%AD-%ED%95%A8%EC%88%98%EB%A9%94%EC%84%9C%EB%93%9C) 파트에서 `eval` 함수를 살펴봤다

  전역 객체의 `eval` 메서드와 해당 메서드에 문자열로 전달된 소스코드를 `eval` 코드라고 부른다. `eval` 코드는 JS 엔진에 의해 평가되면 스코프를 동적으로 변경하는 하는 자신만의 자체적인 스코프를 생성해야 하기 때문에, 이를 위해 `eval` 코드는 평가되어 `eval` 실행 컨텍스트를 생성하게 된다

  ```javascript
  const x = 1;
  
  function func() {
    // 원래 변수 선언문은 호이스팅 된다
    // 그러나 eval 코드는 평가되어 자체적인 스코프를 생성한다
    // 따라서 eval 코드 위 참조문의 x는 전역 변수를 참조한다
    console.log(x); // → 1
    eval("const x = 2");
    console.log(x); // → 1
  }
  
  func();
  console.log(x); // → 1
  ```

- **모듈 코드**

  > 모듈에 대해서는 [모듈]() 파트를 참고하자

  모듈은 하나의 `.js` 파일에 몰려 있는 JS 소스코드를 특정 기준에 따라 여러 파일에 나누어 작성하고 상호 연결을 통해 필요한 코드를 재사용할 수 있는 시스템을 의미한다. 분리된 모든 파일들은 서로 연결되어 있기 때문에 코드 중복의 문제들을 해결하기 위해 모듈별로 독립적인 모듈 스코프가 필요하다. 모듈 코드는 평가되면 모듈 실행 컨텍스트를 생성하게 되고, 이를 통해 모듈 스코프를 생성하게 된다

  ```javascript
  // index.js 파일
  function printHello {
    console.log("Hello");
  }
  
  // CommonJS 형태의 모듈 코드
  // 모듈 코드는 평가되어 모듈 실행 컨텍스트를 생성한다
  module.exports = {
    printHello
  };
  ```

  ```javascript
  // commonFunction.js 파일(공통적으로 자주 사용되는 함수를 따로 모은 파일)
  
  const func = require("./index.js")
  func.printHello(); // → Hello
  ```

### 1-2 소스코드의 평가와 실행

앞서 [표현식과 문](https://github.com/jacenam/WIL-archive/blob/main/Web%20Development/JS/JS%20Basics/expression%20%26%20statement(feat.%20value%2C%20literal).md) 파트에서 일부 살펴본 내용으로 JS에서 소스코드는 JS 엔진에 의해 "평가"와 "실행"의 과정으로 나뉘어 실행된다

소스코드 평가 과정에서 위에서 언급한 4가지 타입의 실행 컨텍스트를 생성하고, 변수와 함수 등의 선언문을 먼저 실행하는 호이스팅, 그리고 생성된 식별자(변수, 함수, 클래스 등)를 [렉시컬 환경](#3-1-렉시컬-환경)에 등록하여 키와 값의 형태로 관리한다

이러한 소스코드의 평가 과정이 완료되면 비로서 소스코드가 한 줄씩 순차적으로 실행되는 런타임이 시작된다. 그리고 JS 엔진은 런타임에 소스코드가 실행되므로 식별자와 연결된 정보(값)를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득한다. 그리고 소스코드의 실행 결과를 다시 실행 컨텍스트가 관리하는 스코프에 등록한다. 마치 변수의 동작 원리 파트에서 다뤘듯이 선언문 평가, 값의 할당, 변수의 참조 및 소스코드의 결과를 메모리에 재등록하는 과정과 유사하다

<img src="https://github.com/jacenam/WIL-archive/assets/92138751/414de7ff-fce6-4b52-b2ad-5ed2da166c3e" width="100%">

아래 예제를 살펴보자. 앞서 [값의 할당](https://github.com/jacenam/WIL-archive/blob/main/Web%20Development/JS/JS%20Basics/assignment.md#1-1-%EA%B0%92%EC%9D%98-%ED%95%A0%EB%8B%B9%EA%B3%BC-%EB%A9%94%EB%AA%A8%EB%A6%AC) 파트에서 언급했듯이 변수 선언과 값의 할당이 동시에 이뤄지는 변수 선언 및 할당문의 경우 하나의 코드 문장처럼 보이지만 JS 엔진은 이를 2개의 과정으로 나누어 처리한다고 했다

1. 변수 선언 `var x;`
2. 값의 할당 `x = 1;`  

```javascript
var x = 1; 
```

소스코드의 평가 및 실행 측면으로 바라보면 변수 선언과 할당이 왜 2단계로 나뉘어져 처리되는지 이해할 수 있다

<img src="https://github.com/jacenam/WIL-archive/assets/92138751/08be76a7-54a9-4fa7-98e6-8aefa0b8344b" width="100%">

0. (종류별 실행 컨텍스트의 생성)

1. 소스코드의 평가 `var x;`

   전체 소스코드 중 식별자의 탐색과 호이스팅, 실행 컨텍스트의 스코프(렉시컬 환경)에 등록

2. 소스코드의 실행 `x = 1;`: 

   런타임에 값의 할당이 시작된다. `x` 변수가 선언된 변수인지 확인이 필요하기 때문에, JS 엔진은 (1) 실행 컨텍스트의 스코프에 `x` 변수가 등록되어 있는지 확인한다.  확인이 완료되면 값을 `x` 변수에 할당한다. 마지막으로 (3) 실행 결과를 다시 실행 컨텍스트에 등록한다

### 1-3 실행 컨텍스트의 역할

모든 소스코드는 실행되려면 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다. 실행 컨텍스트는 모든 소스코드를 실행하는 데 있어 필요한 환경을 제공하고 실행 결과를 관리한다. 실행 컨텍스트는 대표적으로 아래와 같은 기능을 수행한다: 

- **식별자의 스코프 구분과 상태 변화 관리**

  선언에 의해 생성된 식별자(변수, 함수, 클래스 등)의 스코프를 구분해서 실행 컨텍스트에 등록하고 이들에게 바인딩된 값의 변화를 지속적으로 트래킹하고 관리한다

- **스코프 체인 형성**

  선언에 의해 생성된 식별자 간의 스코프 중첩 관계를 구분해서 스코프 체인을 형성하고 이를 실행 컨텍스트에 등록한다. JS 엔진은 실행 컨텍스트에 등록된 스코프 체인을 따라 상위 스코프로 이동하며 필요한 식별자를 검색한다

- **코드 실행 순서 관리**

  JS는 인터프리터 언어로서 위에서 아래로 한 줄씩 코드가 실행되는 코드 흐름을 기본적으로 가진다. 그러나, 예를 들어 함수 호출에 의해 실행 순서가 변경될 때 중간에 흐름이 바뀐 지점을 실행 컨텍스트에 등록한다. 함수 호출에 의해 함수가 실행되고 난 뒤 다시 원래의 순서로 돌아올 때 실행 컨텍스트에 등록된 정보를 기반으로 코드의 흐름이 다시 정상적으로 실행되는 것이다

  ```javascript
  // (1)
  const x = 1; 
  
  // (2)
  function foo(y) {
    console.log(x + y);
  }
  
  // (3)
  // 함수 호출로 인해 코드의 실행 흐름은 (2)로 돌아가 함수 내부의 문을 실행한다
  foo(2);
  
  // (4) 함수 실행이 종료되면 다시 원래의 코드 실행 흐름대로 돌아와 (4)를 실행한다
  const z = 3; 
  ```

아래 예제를 살펴보자. JS 엔진은 아래 예제 코드를 어떻게 실행 컨텍스트를 통해 실행하고 관리하는지 알 수 있다

```javascript
// 전역 코드 - 전역 변수 선언
const x = 1;
const y = 2;

// 전역 코드 - 전역 함수 정의
function foo(z) {
	// 지역 코드 - 지역 변수 선언
  const x = 10;
  const y = 20; 
  
  // console 메서드 호출
  console.log(x + y + z);
}

// 함수 호출
foo(100);

// console 메서드 호출
console.log(x + y); 
```

1. **전역 코드 평가**

   JS 엔진은 먼저 전역 코드를 평가해서 식별자의 선언문만 먼저 실행한다(호이스팅). 평가 결과로 생성된 전역 변수와 전역 함수 식별자를 실행 컨텍스트가 관리하는 전역 스코프에 등록한다. 만약 `var` 키워드로 선언된 전역 변수는 전역 객체의 프로퍼티가 된다

   <img src="https://github.com/jacenam/WIL-archive/assets/92138751/40646617-abd4-4cc4-8a3b-a435c6082d0a" width="100%">

2. **전역 코드 실행**

   전역 코드의 평가 과정이 종료되면 코드가 한 줄씩 순서대로 실행되는 런타임에 돌입한다. 런타임에 전역 코드는 순차적으로 실행되기 시작한다. [이때 전역 변수에 값이 할당](https://github.com/jacenam/WIL-archive/blob/main/Web%20Development/JS/JS%20Basics/assignment.md#1-2-%EA%B0%92%EC%9D%98-%ED%95%A0%EB%8B%B9-%EC%8B%9C%EC%A0%90feat-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85)되고 함수는 호출문을 통해 호출된다. 함수가 호출되면 순차적으로 실행되던 전역 코드의 흐름이 일시 중단되고 코드의 실행 순서는 함수 내부로 변경된다. 이 때 실행 컨텍스트에 전역 코드의 중단 시점 정보가 등록된다

   <img src="https://github.com/jacenam/WIL-archive/assets/92138751/3e8ea1b7-a581-41f0-9b66-94520e85d429" width="100%">

3. **함수 내부 코드 평가 (코드 흐름의 변경)**

   앞서 전역 코드의 평가 과정에서 식별자의 선언문만 먼저 실행된다고 했다. 즉, 함수 선언문의 식별자(함수 이름) 호이스팅이 발생하지만, 함수 내부의 코드는 바로 평가되지 않는다. 함수 호출 시 코드의 흐름이 함수 내부로 변경되기 때문에 JS 엔진은 이때부터 함수 내부의 코드를 평가하기 시작한다. 전역 코드 평가와 마찬가지로, 함수 내부에서 선언된 식별자(매개변수, 지역 변수)가 먼저 실행되고 평가 결과로 생성된 지역 변수와 매개변수 식별자를 함수 실행 컨텍스트가 관리하는 지역 스코프에 등록된다

   <img src="https://github.com/jacenam/WIL-archive/assets/92138751/754e91f6-88db-4705-a963-c8bf50d0909f" width="100%">

4. **함수 코드 실행**

   함수 코드의 평가 과정이 종료되면 함수 내부의 런타임이 시작되어 함수 내부의 문들을 순차적으로 실행한다. 이때 매개변수와 지역 변수에 값이 할당되고 `console.log` 메서드(전역 객체 `window`의 메서드)가 호출된다

   JS 엔진은 `console.log` 메서드를 호출하기 위해 식별자(프로퍼티 이름 `console`)를 실행 컨텍스트 관리하는 스코프 체인을 통해 검색하기 시작한다. 함수 실행 컨텍스트에서 관리하는 지역 스코프에서 스코프 관계를 전역 실행 컨텍스트에서 관리하는 상위 스코프(전역 스코프)로 이동하며 검색이 이뤄진다. `console` 식별자는 전역 객체 `window`의 프로퍼티이기 때문에 전역 스코프를 통해 검색해야 하기 때문이다

   <img src="https://github.com/jacenam/WIL-archive/assets/92138751/4b98ae67-d117-4055-8c01-74669afa8313" width="100%">

   전역 객체 `window`의 프로퍼티인 `console`은 객체이기도 하다. 따라서 JS 엔진은 `console` 객체의 `log` 메서드를 검색하기 시작하는데, `log` 메서드는 `console.prototype` 객체의 메서드로서 프로토타입 체인을 통해 검색된다. `console.log` 메서드가 검색되고 실행되면 인수로 전달된 `x+y+z` 표현식이 평가된다. `x`, `y`, `z` 식별자는 다시 스코프 체인을 통해 검색된다

   <img src="https://github.com/jacenam/WIL-archive/assets/92138751/09ae2c9a-40c9-44a5-b82a-c3a735291b3b" width="100%">

5. **함수 호출 이전 코드 흐름으로 복귀**

   `foo` 함수 내부의 `console.log` 메서드의 실행이 종료되면 함수 코드의 실행 과정이 모두 종료된다. 그리고 JS 엔진은 전역 실행 컨텍스트에 등록된 전역 코드의 중단 시점 정보를 통해 코드의 실행 흐름을 함수 호출 이전으로 되돌려 전역 코드의 실행을 계속하게 되는 것이다
   
   <img src="https://github.com/jacenam/WIL-archive/assets/92138751/67910aac-dced-4f51-9d4b-155cea48c920" width="100%">

이처럼 실행 컨텍스트는 식별자를 등록하고 스코프와 코드의 실행 순서까지 관리하는 JS의 내부 메커니즘이다. 실행 컨텍스트는 식별자와 스코프를 구분하고 상태 변화를 관리할 때 [렉시컬 환경]()으로 관리하고, 코드의 실행 순서는 실행 컨텍스트 스택으로 관리한다. 실행 컨텍스트 스택에 대해서는 바로 뒤에 다룰 내용을 참고하자

<br>

## 2 실행 컨텍스트 스택

JS 엔진은 한 줄씩 코드를 순차적으로 실행하며 [소스코드의 종류](#1-1-소스코드의-종류)에 따라 실행 컨텍스트를 생성한다. 생성된 실행 컨텍스트는 생성된 순서에 따라 쌓이는 형태의 [스택(Stack) 자료구조]()를 통해 관리되는데,  이를 실행 컨텍스트 스택이라 부르며 스택은 후입선출(LIFO, Last-in-First-out)의 순서를 가진다

아래 예제를 살펴보면 JS 엔진은 먼저 런타임 이전에 전역 코드를 평가하여 전역 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 추가(Push)된다. 그리고 런타임에는 전역 코드를 실행한다. 그러다가 함수 호출문에 도달하면 함수가 호출되어 함수 코드를 평가하여 함수 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 추가된다. 이런식으로 먼저 스택에 쌓인 실행 컨텍스트 이후에 다른 실행 컨텍스트가 쌓이게되면, 나중에 쌓인 실행 컨텍스트부터 처리하여 처리 완료된 실행 컨텍스트는 제거(Pop)되는 구조라고 이해하면 된다

```javascript
const x = 1;

function outerFunc() {
  const y = 2; 
  
  function innerFunc() {
    const z = 3;
    console.log(x + y + z);
  }
  innerFunc();
}

foo(); // → 6
```

실행 컨텍스트 스택의 최상위에 쌓인 실행 컨텍스트는 언제나 현재 실행되어 처리되는 코드(전역, 함수, `eval`, 모듈)의 실행 컨텍스트라는 것을 알 수 있다(실행 컨텍스트 스택 최상위 = 현재 실행되는 코드)

<img src="https://github.com/jacenam/WIL-archive/assets/92138751/e9d56636-5a55-46cf-83c4-a3e7a7796307" width="100%">

위 예제를 단계별로 살펴보자

1. **전역 코드의 평가 후 실행**

   - 전역 코드의 평가 시 `x` 전역 변수, `outerFunc` 전역 함수가 호이스팅되고 전역 실행 컨텍스트가 생성되어 식별자들을 등록한다. 그리고 전역 실행 컨텍스트는 실행 컨텍스트 스택에 추가된다

     <img src="https://github.com/jacenam/WIL-archive/assets/92138751/5ab0ce0f-20de-441e-8dfc-b654555e06ed" width="100%">

   - 전역 코드의 실행 시 `x` 변수에 값의 할당이 이뤄지고, `outerFunc` 함수가 호출된다. 함수 호출로 인해서 코드의 실행 흐름은 `outerFunc` 함수 내부로 변경되며 추후 코드 실행 순서의 복귀를 위해 함수의 호출 시점은 전역 실행 컨텍스트에 등록된다

     <img src="https://github.com/jacenam/WIL-archive/assets/92138751/f0ad353b-734e-4454-9c43-9fcccdf917d7" width="100%">

2. **`outerFunc` 함수 코드의 평가 후 실행**

   - `outerFunc` 함수의 내부 코드 평가 시 `y` 지역 변수와 `innerFunc` 중첩 함수가 호이스팅되고 함수 실행 컨텍스트가 생성되어 식별자들을 등록한다. 그리고 함수 실행 컨텍스트는 실행 컨텍스트 스택에 추가된다

     <img src="https://github.com/jacenam/WIL-archive/assets/92138751/aa3f073f-f48c-4e6c-bf1f-4bf9d8b32c19" width="100%">

   - `outerFunc` 함수 내부의 코드 실행 시 `y` 지역 변수에 값의 할당이 이뤄지고, `innerFunc` 중첩 함수가 호출된다. 함수 호출로 인해서 코드의 실행 흐름은 `innerFunc` 함수 내부로 변경되며 추후 코드 실행 순서의 복귀를 위해 함수의 호출 시점은 함수 실행 컨텍스트에 등록된다

     <img src="https://github.com/jacenam/WIL-archive/assets/92138751/d7138b2e-fa0d-4386-a135-c283d62fbeab" width="100%">

3. **`innerFunc`  함수 코드의 평가 후 실행**

   - `innerFunc` 함수 내부의 코드 평가 시 `z` 지역 변수가 호이스팅되고 `innerFunc` 함수를 위한 함수 실행 컨텍스트가 생성되어 `z` 지역 변수를 등록한다. 그리고 함수 실행 컨텍스트는 실행 컨텍스트 스택에 추가된다

     <img src="https://github.com/jacenam/WIL-archive/assets/92138751/4a6fd682-2794-4b37-ac61-5f177a957360" width='100%'>

   - `innerFunc` 함수 내부의 코드 실행 시 `z` 지역 변수에 값의 할당이 이뤄지고, `console.log` 메서드가 호출된다. `console.log` 메서드의 실행을 위해 JS 엔진은 지역 스코프에서부터 전역 스코프까지 `console` 프로퍼티를 탐색한다. 전역 객체 `window`의 프로퍼티인 `console` 프로퍼티 검색 후 `console.prototype`의 프로토타입 체인을 통해 `log` 메서드를 상속받아 호출한다. `x`, `y`, `z` 식별자는 각 실행 컨텍스트가 관리하는 스코프 체인을 통해 검색하여 각 식별자에 바인딩된 값을 참조한다

     <img src="https://github.com/jacenam/WIL-archive/assets/92138751/176302dc-6b32-4fc0-8a04-896fca316d05" width="100%">

     그리고 `innerFunc` 함수 내부 코드가 모두 실행되면 실행 컨텍스트 스택에서 `innerFunc` 함수 실행 컨텍스트는 제거된다

     <img src="https://github.com/jacenam/WIL-archive/assets/92138751/417cf0d1-7d36-47bd-9a98-246e002c7908" widht="100%">

4. **`outerFunc` 함수 코드로의 복귀**

   - `innerFunc` 함수가 종료되면 코드의 실행 흐름은 `outerFunc` 함수로 이동한다. 그리고 `outerFunc` 함수도 더 이상 실행할 코드가 없기 때문에 종료된다. 그럼 JS 엔진은 `innerFunc` 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 제거(Pop)한다

     <img src="https://github.com/jacenam/WIL-archive/assets/92138751/3c43e181-6cd9-4ae3-ac54-6545ef774720" width="100%">

5. **전역 코드로의 복귀**

   -  `outerFunc` 함수가 종료되면 코드의 실행 흐름은 다시 전역 코드로 이동한다. 전역 코드도 더 이상 실행할 코드가 남아있지 않게되면 전역 실행 컨텍스트도 스택에서 제거되어 실행 컨텍스트 스택에는 아무것도 남아있지 않게 된다

     <img src="https://github.com/jacenam/WIL-archive/assets/92138751/95887044-80d4-4a16-9ad0-b7fc8c8ab94f" width="100%">

<br>

## 3 렉시컬 환경

실행 컨텍스트는 `LexicalEnvironment`와 `VariableEnvironment` 컴포넌트로 구성된다. 소스코드가 평가되는 과정에서 실행 컨텍스트는 소스코드 형태에 따라 종류별로 생성된다. 실행 컨텍스트가 생성되는 초기에는 아래 그림처럼 각 컴포넌트들은 하나의 동일한 렉시컬 환경을 참조한다

<img src="https://github.com/jacenam/WIL-archive/assets/92138751/9538781b-7d18-42b2-a8ca-97c8f8025f85" width="100%">



앞서 JS 엔진이 소스코드를 평가할 때 소스코드 형태에 따라 실행 컨텍스트를  종류별로 생성하고 실행 컨텍스트 스택을 통해 코드의 실행 순서를 관리한다 했다. 한편, 식별자와 스코프는 앞서 [소스코드의 평가와 실행](#1-2-소스코드의-평가와-실행)에서 언급했듯이 렉시컬 환경(Lexical Environment)이 관리한다





식별자와 식별자에 바인딩(할당)된 값, 그리고 상위 스코프에 대한 참조 정보를 지닌 자료구조로서 실행 컨텍스트의 구성 요소 중 하나다. 렉시컬 환경은 키는 식별자, 값은 식별자 값의 객체 형태로 스코프를 생성하고 식별자와 식별자 값을 관리한다

```javascript
const x = 1;

function foo() {
  const y = 2;
  console.log(x + y);
}
```

<img src="https://github.com/jacenam/WIL-archive/assets/92138751/a1976b03-4330-4877-8591-6325c4764e85" width="100%">

실행 컨텍스트는 

실행 컨텍스트는 렉시컬 환경(LexcialEnvironment)와 (VariableEnvironment)두 가지 컴포넌트(요소)로 구성된다.



<br>

## 4 실행 컨텍스트의 생성과 식별자 검색 과정

<br>

## 5 실행 컨텍스트와 블록 레벨 스코프

<br>

***

### 참고

- [모던 자바스크립트 Deep Dive]()