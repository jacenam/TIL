# 전역 변수의 문제점

앞서 [스코프](https://github.com/jacenam/WIL-archive/blob/main/Web%20Development/JS/JS%20Basics/Scope/scope.md)에 대한 내용 중 실무 프로그래밍에서 전역 변수의 사용을 지양한다고 했다. 전역 변수의 무분별한 사용은 프로그래밍상 의도치 않은 오류들을 야기할 수 있기 때문이다. 전역 변수의 문제점들을 상세히 다뤄보자

**Table of Contents**

- [변수의 생명 주기](#변수의-생명-주기)
  - [지역 변수의 생명 주기](#지역-변수의-생명-주기)
  - [전역 변수의 생명 주기](#전역-변수의-생명-주기)
- [전역 변수의 문제점](#전역-변수의-문제점)
  - [암묵적 결합](#암묵적-결합)
  - [긴 생명 주기](#긴-생명-주기)[스코프 체인 상에서 종점(최상위 스코프)에 존재](#스코프-체인-상에서-종점(최상위-스코프)에-존재)
  - [네임스페이스 오염](#네임스페이스-오염) 
- [전역 변수의 사용을 억제하는 방법](#전역-변수의-사용을-억제하는-방법)

<br>

## 변수의 생명 주기

[변수와 메모리의 동작 방식](https://github.com/jacenam/WIL-archive/blob/main/Web%20Development/JS/JS%20Basics/variable.md#2-%EB%B3%80%EC%88%98%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC) 파트에서 언급했듯이, 변수는 '선언 - 할당'을 통해 메모리 공간을  확보하여 값을 할당한다. 만약 이렇게 확보된 메모리 공간에 변수가 계속해서 용량을 차지하고 있다면 프로그램의 효율이 떨어질 것이다. 따라서 변수에는 생성되고 소멸되는 생명 주기(Life Cycle)가 존재한다. 그러나 변수의 생명 주기는 변수가 선언된 위치(전역, 지역)에 따라 상이하게 된다

### 지역 변수의 생명 주기

불필요한 변수의 생성 및 유지는 그만큼의 메모리 공간을 차지하기 때문에 비효율적이다. 예를 들어 아래와 같이 1000줄이 넘는 변수 선언 프로그램이 있다고 가정해보자: 

```javascript
var a1 = 1;
var a2 = 2;
var a3 = 3; 
...;
...;
var a999 = 999;
var a1000 = 1000;
```

변수 `a1`에서 `a1000`은 전역(코드의 가장 바깥 영역)에서 선언되었기 때문에 위 프로그램이 종료될 때까지 변수들이 메모리의 일정 공간을 점유하고 소멸되지 않는다. 즉, 프로그램과 전역 변수는 생명 주기가 같다

하지만 지역(함수 내부)에서 선언된 변수는 함수가 호출되어 함수 내부 코드가 실행되었을 때만 생성되며 함수가 종료되면 소멸하여 메모리 측면에서 더욱 효율적이다. 함수 호출이 없다면 함수 내부의 변수 선언문 또한 실행되지 않기 때문이다. 아래와 같이 지역 변수로 1000줄의 변수 선언 코드를 두 개의 함수 묶음으로 나눠 굳이 실행이 필요하지 않은 변수로 인한 메모리 낭비를 방지할 수도 있다

```javascript
function program1() {
  var a1 = 1;
  var a2 = 2;
  var a3 = 3;
  ...;
  ...;
  var a499 = 499;
  var a500 = 500;

  return a1 + a2 + a3 + ... + a499 + a500;
}


function program2() {
  var a501 = 501;
  ...;
  ...;
  var a1000 = 1000;
  
  return a501 + a502 + ... + a1000;
}

program1();
```

물론 지역 변수의 생명 주기가 함수의 생명 주기보다 오래 지속되는 경우도 있다. 지역 변수는 함수의 지역 스코프에 등록되는데 특정 상황에서 지역 변수의 메모리 공간을 계속해서 참조하고 있다면 함수가 종료되더라도 지역 변수가 생존하기도 한다. 함수가 종료되면 함수의 지역 스코프도 소멸하는 것이 일반적이지만, 스코프가 계속해서 참조되고 있다면 함수가 종료되더라도 스코프는 해제되지 않는 경우도 있기 때문이다. 이에 대해서는 [클로저]() 파트를 참고하자

### 전역 변수의 생명 주기

앞서 언급했듯이, 전역 변수는 전역 전체에서 유효하다. 따라서 함수와는 달리, 함수 호출과 같은 명시적인 실행 명령 없이 소스코드가 JS 엔진에 의해 해석되고 바로 실행된다. 또한, 함수와 같이 함수 몸체의 마지막 문, 반환문이라는 종료를 의미하는 코드가 없어 변수가 실행된 이후 프로그램이 종료되어야만 소멸된다

전역 변수가 선언되면 브라우저 환경에서는 `window`, node.js 환경에서는 `console`, `module`과 같은 `global`/전역 객체의 프로퍼티가 된다. 즉, 브라우저 환경에서 전역 변수는 브라우저의 웹페이지를 종료하기 전까지 생존한다. 그만큼 전역 변수의 생명 주기가 길다는 의미라고 이해하면 된다

> 전역 객체(Global Object)에 대한 내용은 현재로서 깊게 다루지 않을 것이다. JS에서는 모든 값(원시 타입과 객체 타입)이 객체의 형태로 저장되어 관리된다. 즉, 전역 변수 `x`, `y`는 브라우저 환경에서 아래와 같이 저장된다: 
>
> ```javascript
> // 만약 전역 변수를 선언하면
> var x = 1;
> var y = 2;
> 
> // 브라우저 환경에서는 window 객체(전역 객체)로 아래와 같이 등록된다
> window = {
>   x: 1,
>   y: 2,
> }
> ```
>
> 따라서 브라우저에서 `window` 객체의 프로퍼티로 변수 `x`와 `y`의 접근할 수 있다
>
> ```javascript
> // 프로퍼티 접근 연산자를 활용한 객체 값에 접근
> window.x; // → 1
> window.y; // → 2
> 
> // 여러가지 빌트인 객체를 통해 전역 변수에 접근도 가능하다
> alert(window.x); // (alert 팝업) → 1
> ```
>
> 전역 객체와 빌트인 객체에 대한 자세한 내용은 추후 [빌트인 객체]()에서 살펴보자

<br>

## 전역 변수의 문제점

### 암묵적 결합

전역 변수를 사용한다는 의미는 어디서든 참조되거나 재할당할 수 있는 변수를 사용하겠다는 것이다. 모든 코드가 전역 변수를 참조할 수 있기 때문에 의도치 않은 코드 결과를 허용하지 않기 위해서는 전역 변수의 존재를 항상 기억하고 있어야 한다. 즉, 전역 변수의 수가 많아질수록 더 많은 주의가 필요해지는 것이다. 이를 간과한채 전역 변수를 사용하는 것은 의도치 않은 코드 결과를 야기하는 암묵적 결합(Implicit Coupling)을 허용하는 것이므로, 정말 필요할 때만 전역 변수를 사용하는 것이 옳다

### 긴 생명 주기

이미 [전역 변수의 생명 주기](#1-변수의-생명-주기)를 통해 살펴보았듯이, 전역 변수의 생명 주기는 길어 의도치 않은 상태 변경인 암묵적 결합의 가능성이 더욱 높다. 더군다나 `var` 키워드로 선언한 변수는 중복 선언이 가능하여 이러한 전역 변수들이 많이 선언된다면 생명 주기가 긴 만큼 변수인만큼 변수 이름 또한 중복되어 의도치 않은 오류도 야기될 가능성이 더 크다. 생명 주기가 긴 만큼 메모리 공간을 오랫동안 점유하여 비효율적인 메모리 소비를 한다

### 스코프 체인 상에서 종점(최상위 스코프)에 존재

전역 변수는 스코프 체인의 종점에 위치한다. 최상위 스코프로서 모든 지역 스코프에서 전역 변수를 검색할 때 스코프 체인의 종점까지 거슬러 올라가는 과정이 필요하다. 즉, 전역 변수의 식별자 검색 속도가 가장 느리다는 의미다. 우리가 직접 체감하기에는 속도의 차이가 크진 않지만, 프로그램이 복잡해지고 무거워질수록 속도의 차이는 분명히 있다

### 네임스페이스 오염

요즘은 모듈 패턴 혹은 ES6 모듈을 활용하기 때문에 이러한 문제들이 빈번하게 발생하진 않지만, 모듈 패턴과 ES6부터 자체 모듈을 제공하는 이유에 대해서도 알 수 있는 기회다. JS는 파일을 분리하여 변수와 함수들을 관리한다고 해도 하나의 전역 스코프를 공유한다는 큰 단점이 있다. 예를 들어, HTML에서 여러 개의 JS 파일을 연결하면 연결된 JS 파일들은 하나의 JS 파일처럼 동작한다

```html
<html lang="en">
  <head>
    <title>Document</title>
    <script type="text/javascript" src="deepdive1.js"></script>
    <script type="text/javascript" src="deepdive2.js"></script>
    <script type="text/javascript" src="deepdive3.js"></script>
  </head>
  <body>
  </body>
</html>
```

이때, 전역 변수나 전역에서 정의된 함수가 공유되는 현상이 발생한다. 선언/정의하지 않은 변수 혹은 함수가 사용되어 예상치 못한 방향으로 프로그램이 동작하기도 한다. 따라서 프로그램 작성 시 의도치 않은 오류를 야기할 수 있으며 정확한 오류의 원인을 찾아나가는 일도 하나의 공수가 된다

<br>

## 전역 변수의 사용을 억제하는 방법

전역 변수를 필수적으로 사용해야 할 이유가 없다면, 전역 변수의 사용을 지양하는 가장 기본적인 방법은 함수 내에 지역 변수를 선언해서 사용하는 것이다. 그러나 모든 변수를 지역 변수로 관리 및 사용하기에는 어렵다

- **즉시 실행 함수**

  [라이브러리]()에 자주 사용되는 방법이다. 함수를 정의함과 동시에 호출하는 즉시 실행 함수는 단 한번만 호출되어 사용되므로, 변수를 필요한 상황만큼만 활용하고 소멸시키는데 유용하다

  ```javascript
  (function program1() {
    var a1 = 1;
    var a2 = 2;
    var a3 = 3;
    ...;
    ...;
    var a499 = 499;
    var a500 = 500;
  
    console.log(a1 + a2 + a3 + ... + a499 + a500);
  }());
  ```

- **네임스페이스 객체**

  > 객체 패턴을 활용한 식별자 관리 방법으로 식별자 충돌(중복)을 방지하는 효과는 있으나, 객체 자체를 전역 변수에 할당하는 형태이므로 전역 변수 억제 방법으로는 권장하지 않는다(이해를 위해 첨부한다). 

  전역 변수로 사용하고 싶은 변수들을 [객체 프로퍼티](https://github.com/jacenam/WIL-archive/blob/main/Web%20Development/JS/JS%20Basics/Data%20Type/object%20type.md)에 추가하여 전역 변수를 관리하는 '네임스페이스 객체'를 활용하는 방법이다

  ```javascript
  var INFO = {
    name: "Jace",
    age: 31,
    address: "Seoul",
  };
  
  console.log(INFO.name, INFO.age, INFO.address); // → Jace 31 Seoul
  ```

- **모듈 패턴**

  모듈 패턴은 [클래스]()를 모방해서 필요한 변수와 함수를 모아 즉시 실행 함수로 실행시키는 하나의 모듈을 만드는 것이다. 모듈 패턴은 [클로저]()와 클래스에 대한 이해가 필요하므로 추후 자세히 다룰 예정이다

- **ES6 모듈**

  앞서 [네임스페이스 오염](#2-4-네임스페이스-오염) 내용에서 JS는 파일을 분리해도 하나의 스코프를 공유하여 전역 변수, 전역에서 정의된 함수를 공유한다고 했다. 이러한 단점을 개선하기 위해 ES6부터 ES6 모듈을 제공하기 시작했다. ES6 모듈은 각 JS 파일별로 필요한 코드들을 분리하는 것은 동일하지만, 파일마다 독자적인 스코프를 가지게 되므로 파일별 전역 변수, 전역에서 정의된 함수가 공유되지 않는다

  ```html
  <script type="module" src="deepdive1.mjs"></script>
  <script type="module" src="deepdive2.mjs"></script>
  <script type="module" src="deepdive3.mjs"></script>
  ```

  그러나 ES6 모듈은 최신 기능인만큼 일부 브라우저에서 동작하지 않는다. 모듈에 대한 내용 또한 추후 자세히 다룰 예정이다

<br>

## 참고

- [모던 자바스크립트 Deep Dive](http://www.yes24.com/Product/Goods/92742567)
- [모던 JavaScript 튜토리얼 - 전역 객체](https://ko.javascript.info/global-object) 
- [전역 객체 `window`](https://opentutorials.org/course/1375/6633)
- [Node.js 전역 객체와 전역 변수](https://tutorialpost.apptilus.com/code/posts/nodejs/ns-global-object/)
- [Oject Model](https://opentutorials.org/course/1375/6622)
- [전역 변수를 왜 지양해야 하는가](https://intzzzero.netlify.app/blog/no-more-global-variables)
- [[JavaScript] 전역 변수 사용을 줄여보자, 근데 어디까지 전역변수야?](https://hellvelopment.tistory.com/77)

