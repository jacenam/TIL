# 암묵적 타입 변환

JS 엔진은 표현식을 에러 없이 평가하기 위해 개발자의 의도와는 상관없이 코드의 문맥을 고려해 암묵적으로 데이터 타입을 강제 변환할 때가 있다. 이를 암묵적 타입 변환(Implicit Coercion)이라 한다. 암묵적 타입 변환에 대해 알아보자

### 목차

- [1 암묵적 타입 변환이란](#1-암묵적-타입-변환이란)
- [2 문자열 타입으로의 변환](#2-문자열-타입으로의-변환)
- [3 숫자 타입으로의 변환](#3-숫자-타입으로의-변환)
  - [3-1 산술 연산자와 숫자 타입으로의 형변환](#3-1-산술-연산자와-숫자-타입으로의-형변환)
  - [3-2 비교 연산자와 숫자 타입으로의 형변환](#3-2-비교-연산자와-숫자-타입으로의-형변환)
    - [3-2-1 동등/일치 비교 연산자](#3-2-1-동등/일치-비교-연산자)
    - [3-2-2 대소 관계 비교 연산자](#3-2-2-대소-관계-비교-연산자)
- [4 불리언 타입으로의 변환](#4-불리언-타입으로의-변환)
  - [4-1 제어문에서의 형변환](#4-1-제어문에서의-형변환)
  - [4-2 삼항 조건 연산자 조건식에서의 형변환](#4-2-삼항-조건-연산자-조건식에서의-형변환)
  - [4-3 논리 연산자에서의 형변환](#4-3-논리-연산자에서의-형변환)
  - [4-4 비교 연산자와의 형변환 차이](#4-4-비교-연산자와의-형변환-차이)

***

<br>

## 1 암묵적 타입 변환이란

암묵적 타입 변환은 타입 강제 변환(Type Coercion)이라고도 한다. 중요한 것은 암묵적 타입 변환이 발생하면 **숫자, 문자열, 불리언과 같은 원시 타입 중 하나로 타입을 새로 생성한다**는 점이다

```jsx
var num = 10; 
var str = num + '';

console.log(str, typeof str); // → 10 string
```

연산자 `+`가 문자열 연결 연산자로서 기능하여 표현식 `num + ‘’`은 문자열 값인 `‘10’`으로 평가된다

그렇다면 JS 엔진은 왜 암묵적으로 타입 변환을 수행하는 것일까:

- 개발자가 잘못 넣은 데이터 타입을 코드 문맥상 올바른 타입으로 변환해 오류 없이 코드 실행을 하기 위함이다 (물론, 암묵적 타입 변환으로 인해 오류가 발생하기도 한다)
- (서버에서 데이터를 받아올 때) 개발자가 코드 실행을 위해 필요한 데이터 타입으로 명시적 변환할 수 있지만, 일일이 모든 타입을 명시적으로 맞추기 힘들다

<br>

## 2 문자열 타입으로의 변환

문자열 타입으로의 암묵적 변환은 `+` 연산자가 핵심이다. `+` 연산자는 표현식 안에 최소 한개 이상의 피연산자가 문자열 타입일 때 문자열 연결 연산자로서 동작한다

```jsx
1 + '2'; // → '12'
```

(실제 코드와는 달리) 코드 문맥상 모든 피연산자가 문자열 타입으로 형변환 된다. JS 엔진은 문자열 연결 연산자가 들어간 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중 문자열 값이 아닌 숫자 값 `1`을 문자열 타입으로 암묵적 타입 변환한다

JS 엔진이 문자열을 제외한 모든 데이터 타입을 문자열 타입으로 암묵적 변환을 수행할 때 아래와 같이 동작한다:

```jsx
// 숫자 타입
0 + ''; // → '0'
1 + '1'; // → '11'
NaN + ''; // → 'NaN'
NaN + '100'; // → 'NaN100'
...

// 불리언 타입
true + ''; // → 'true'
false + '123'; // → 'false123'

// null 타입
null + ''; // → 'null'
null + 'nothing'; // → 'nullnothing'

// undefined 타입
undefined + ''; // → 'undefined'
undefined + '0'; // → 'undefined0'

// 심벌 타입
（Symbol()) + ''; // → TypeError: Cannot convert a Symbol value to string

// 객체 타입
({}) + ''; // → '[object Object]'
Math + '0'; // → '[object Math]0'
[] + ''; // → ''
[10, 20] + '30'; // → '10, 2030'
...*
```

위 예제를 통해 알 수 있듯이, 문자열 연결 연산자는 JS의 모든 데이터 타입 중 심벌 타입을 제외하고는 모두 문자열 타입으로 암묵적 타입 변환이 가능하다

그렇다면 피연산자가 2개(이항 산술) 이상일 때 문자열 연결 연산자는 어떻게 동작할까:

```jsx
1 + 1 + '1'; // → *'21'*
'1' + 1 + '1'; // → *'111'* 
**undefined + null + '1'; // → *'NaN1'*
null + '' + 'nothing'; // → *'nullnothing'*
```

문자열 연결 연산자는 [이항 산술 연산자 `+`]()와 [**결합 순서**]()(좌항 → 우항)가 동일하다. 좌항부터 차례대로 연산을 수행해 나간다.

```jsx
1 + 1 + '1'; // → '21'
```

표현식 `1 + 1 + ‘1’`과 같이 숫자 타입과 숫자 타입이 먼저 연산이 되는 경우 `+` 산술 연산자로서 동작하여 숫자 값 `2`를 생성하고  숫자 값 `2`와 문자열 값 `‘1’`이 연산될 때는 문자열 연산자로서 동작한다.

<br>

## 3 숫자 타입으로의 변환

피연산자가 숫자 타입으로 암묵적 타입 변환되는 이유는 두 가지다:

1. 산술 연산자의 산술 연산을 위해 암묵적 타입 변환된다
2. 비교 연산자의 비교 연산을 위해 암묵적 타입 변환된다

### 3-1 산술 연산자와 숫자 타입으로의 형변환

[산술 연산자]()(**`+`, `-`, `\*`, `/`, `%`**)**의 역할은 **숫자 타입의 피연산자들을 산술 연산하여 새로운 숫자 값을 생성하는 것이다. 산술 연산자를 통해 다른 데이터 타입을 생성할 수 없다. 따라서, 피연산자들을 산술 연산이 가능한 숫자 타입으로 변환하여 산술 연산을 수행한다

```jsx
1 - '1' => 1 - 1; // → 0
1 * '10' => 1 * 10; // → 10
```

JS 엔진은 산술 연산자가 들어간 표현식을 평가하기 위해 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환하여 산술 연산자의 기능을 수행한다

산술 연산이 불가능할 경우, `NaN`을 반환한다

```jsx
1 * 'three'; // → NaN
```

피연산자를 숫자 타입으로 변환할 수 없는 경우, 산술 연산을 수행할 수 없으므로 산술 연산자 표현식의 평가 결과는 `NaN`이 된다

JS 엔진이 숫자 타입을 제외한 모든 데이터 타입을 숫자 타입으로 암묵적 변환을 수행할 때 아래와 같이 동작한다:

```jsx
// 문자열 타입
+''; // → 0
+'0'; // → 0
+'1'; // → 1
+'string'; // → NaN

// 불리언 타입
+true; // → 1
+false; // → 0

// null 타입
+null; // → 0

// undefined 타입
+undefined; // → NaN

// 심벌 타입
+Symbol(); // → TypeError: Cannot convert a Symbol value to a number*

// 객체 타입
+{}; // → NaN
+[]; // → 0
+[10, 20]; // → NaN
+(function(){}); // → NaN
```

위 예제 코드를 정리하자면:

- [`+` 단항 산술 연산자**]()는 **심벌 타입의 피연산자를 제외한** 모든 타입의 피연산자를 숫자 타입의 값으로 암묵적 타입 변환한다

  ```jsx
  // 문자열 타입
  + '' // → 0
  + '1' // → 1
  +'string'; // → NaN
  
  // 불리언
  +true // → 1
  +false // → 0
  
  // null 타입
  ...
  ```

- JS 엔진은 산술 연산자(`+` 단항 연산자도 산술 연산자에 포함된다)가 들어간 표현식의 평가를 위해 **빈 문자열(`’’`), 빈 배열(`[]`), `null`, `false`는 숫자 타입 `0`으로 암묵적 타입 변환한다**

  ```jsx
  // 빈 문자열
  +''; // → 0
  '' / 123; // → 0
  
  // 빈 배열
  +[]; // → 0
  [] - 1; // → -1
  [] * 100; // → 0
  
  // 숫자 타입 null
  +null; // → 0
  null % 1; // → 0
  null + null + 1; // → 1
  
  // 불리언 타입 false
  +false; // → 0
  false - 1; // → -1
  false * 123; // → 0
  ```

- JS 엔진은 산술 연산자가 들어간 표현식의 평가를 위해 `true`는 숫자 타입 `0`으로 암묵적 타입 변환한다

  ```jsx
  // 불리언 타입 true
  +true; // → 1
  true + false; // → 1
  true * false; // → 0
  true / 4; // → 0.25
  ```

- 객체, 빈 배열이 아닌 배열, `undefined`는 변환되지 않아 `NaN`이 된다

  ```jsx
  // 객체 타입
  +(function(){}); // → NaN
  
  // 빈 배열이 아닌 배열
  +[10, 20]; // → NaN
  
  // undefined 타입
  +undefined; // → NaN
  ```

> **그렇다면 왜 빈 문자열(`’’`), 빈 배열(`[]`), `null`, `false`는 숫자 타입 `0`으로, `true`는 숫자 타입 `1`로 암묵적 타입 변환되는 것일까?**
>
> 컴퓨터는 `0`과 `1`, 즉 이진법의 기계어를 통해 동작한다
>
> ```jsx
> // 숫자 타입
> 0 // 이진법으로 0이다
> 1 // 이진법으로 1이다
> ```
>
> 컴퓨터는 이진법을 통해 각각의 데이터 타입을 인식하고 처리한다
>
> ```jsx
> // 문자열 타입
> 'a' // 이진법으로 01100001이다
> 'b' // 이진법으로 01100010이다
> 
> // 숫자 타입
> 2 // 이진법으로 10이다
> 3 // 이진법으로 11이다
> 
> ... 
> ```
>
> 다른 데이터 타입과는 달리, 불리언 타입은 오직 두 가지 값 `true`와 `talse`만이 존재한다. 따라서 인간의 참과 거짓 논리인 `true`와 `false`를 기계어인 `1`과 `0`으로 변환해서 간단하게 표현할 수 있다
>
> ```jsx
> // 불리언 타입
> true // 이진법으로 1이다
> false // 이진법으로 0이다
> 
> true == 1; // → true
> false == 0; // → true
> ```
>
> 이에 이진법이 동일한 숫자 타입 `1`과 `0`은 각각 불리언 타입 `true`와 `false`으로 형변환이 가능하다
>
> 그렇다면 빈 문자열(`’’`), 빈 배열(`[]`), `null`를 살펴보자. 빈 문자열(`’’`), 빈 배열(`[]`), `null`은 각각의 데이터 타입은 달라도 동일하게 ‘값이 없는 상태’임을 나타낸다. ‘값이 없는 상태’임을 컴퓨터가 인식할 수 있게 이진법 `0`으로 표현한다
>
> `‘’`, `[]`라는 기호는 문자열과 배열을 나타내는 [**리터럴**]()로서 사람이 이해할 수 있는 문자나 기호를 통해 컴퓨터가 인식할 수 있도록하는 표기법일 뿐이다. 리터럴 내에 입력된 값이 없고 `null` 또한 값이 없는 상태임을 나타낸다
>
> 따라서 빈 문자열(`’’`), 빈 배열(`[]`), `null`은 숫자 타입 `0`, 불리언 타입 `false`와 동일하게 표현할 수 있는 것이다
>
> ```jsx
> '' == 0; // → true
> '' == false; // → true
> 
> [] == 0; // → true
> [] == false; // → true
> 
> +null; // → 0
> ```

### 3-2 비교 연산자와 숫자 타입으로의 형변환

[**비교 연산자**]()는 피연산자들의 타입과 값의 일치 여부 비교 혹은 대소 비교를 통해 **비교 연산자가 들어간 표현식의 평가 결과로 불리언 값만을 생성**한다. 일치 여부 비교와 대소 비교를 위해 피연산자들을 숫자 타입으로 암묵적 타입 변환한다

### 3-2-1 동등/일치 비교 연산자

비교 연산자 중 [**동등/일치 비교 연산자**](https://www.notion.so/8ce3e252770048dca1c970dc1f991d3e)(`==`, `===`, `!=`, `!==`)는 피연산자들의 **값과 타입의 일치 여부를 비교하여 불리언 값만을 생성한다.** 따라서, 피연산자들을 비교 연산이 가능한 숫자 타입으로 암묵적 타입 변환하여 비교 연산을 수행한다

```jsx
'' == 0; // → true
'' + 20 == false + 20; // → true

true + 1 == 2; // → true
false + 100 == '100'; // → true
+true != true; // → false

+null == 0; // → true
+null != false; // → false

[] == false; // → true
+[] + 1 == true; // → true
[] + 2 == true + true; // → true
```

암묵적 타입 변환을 위해 [일치 비교 연산자(엄격한 비교, `===`)]()가 아닌 [동등 비교 연산자(느슨한 비교, `==`)]()를 사용한다. 동등 비교 연산자는 좌항과 우항의 피연산자들이 다른 타입이지만 값이 동등한지 비교 연산을 수행하기 위해 암묵적 타입 변환이 선행으로 이루어지기 때문이다

여기서 주의해야 할 점은 JS 상에서 자기 자신과 비교 연산해도 유일하게 일치하지 않는 값은 `NaN`이다

```jsx
+undefined == NaN; // → false
+(function(){}) == NaN; // → false
+[10, 20] == NaN; // → false
```

객체, 빈 배열이 아닌 배열, `undefined`는 `+` 단항 산술 연산자의 산술 연산이 불가능해 `NaN`으로 변환된다

`NaN`을 정확하게 비교 연산하고 싶다면 [`Number.isNaN()` 함수]()를 사용하면 된다

```jsx
Number.isNaN(+undefined); // → true
Number.isNaN(+(function(){})); // → true
Number.isNaN(+[10, 20]); // → true
```

### 3-2-2 대소 관계 비교 연산자

비교 연산자 중 [대소 관계 비교 연산자]()(`>`, `<`, `>=`, `<=`)는 피연산자들의 크기를 비교하여 불리언 값만을 생성한다. 따라서, 피연산자들을 비교 연산이 가능한 숫자 타입으로 암묵적 타입 변환하여 비교 연산을 수행한다

```jsx
'1' > 0; // → true
'' > -1; // → true

**true > 0; // → true
false > -1; // → true  

[] >= -1; // → true   

null > -1; // → true
```

숫자 타입으로 암묵적 타입 변환이 불가능한 타입의 경우, 타입이 변환되지 않아 `NaN`이 되며 피연산자들의 대소 비교가 불가능하기 때문에 언제나 `false`가 반환된다

```jsx
'Jace' > 0 => NaN > 0; // → false
undefiend > 10 => NaN > 10; // → false
[10, 20] > 9 => NaN > 9; // → false
```

<br>

## 4 불리언 타입으로의 형변환

[**제어문(`if`문, `for`문, `while`문)**]() 또는 [**삼항 조건 연산자**]()의 조건식, [논리 연산자]()(`||` 논리합 연산자, `&&` 논리곱 연산자, `!` 부정 논리 연산자의 표현식은 JS 엔진에 의해 평가되어 평가 결과가 Truthy 값(참으로 평가되는 값), Falsy 값(거짓으로 평가되는 값) 두 가지로 분류로 되고 난 후 불리언 타입 `true`, `false`로 암묵적 타입 변환되어 불리언 값을 생성한다

```javascript
// false로 평가되는 Falsy 값
false 
undefined
null 
0, -0
NaN 
빈 문자열 '' 
```

Falsy 값으로 분류되는 값 외의 **모든 값은 Truthy 값으로 분류**된다

### 4-1 제어문에서의 형변환

다음 예제를 살펴보자:

```jsx
var x = 11; 

if ( x % 2 ) {
	console.log('홀수'); 
} else {
	console.log('짝수'); // → 짝수
} 
```

조건식 `x % 2`의 평가 결과는 숫자 값 `0`이다. 제어문에서 `0`은 Falsy 값으로 분류된다. Falsy 값은 불리언 타입 `false`로 암묵적 타입 변환되며, 조건식 `x % 2`의 평가로부터 생성된 `false`로 인해 `if…else`문에서 `else`블록문(코드 블록)인 `console.log(’짝수');`를 실행하게 된다

### 4-2 삼항 조건 연산자 조건식에서의 형변환

다음 예제를 살펴보자:

```jsx
var x = 10; 

var ternary = x % 2 ? '홀수' : '짝수'; // → 짝수
```

삼항 조건 연산자의 조건식은 위 제어문 예제의 암묵적 타입 변환과 동일한 과정을 갖는다. 조건식 `x % 2`의 평가 결과, Falsy 값으로의 분류, 불리언 타입으로 암묵적 타입 변환되어 세 번째 피연산자(`’짝수'`)가 반환되는 것까지 모두 동일하다

### 4-3 논리 연산자에서의 형변환

다음 예제를 살펴보자:

```jsx
0 || []; // → []
'true' && 1; // → 1
!null; // → true
!!undefined; // → false
```

위 논리 연산자 코드 예제에서 `[]`, `‘true’`, `1`은 Truthy 값으로, `0`, `null`, `undefined`는 Falsy 값으로 분류되어 각각 불리언 타입 `true`와 `false`로 암묵적 타입 변환된다. 논리합 연산자와 논리곱 연산자는 생성된 불리언 값에 해당하는 값을 반환하고, 부정 논리 연산자는 생성된 불리언 값 그대로 반환한다

### 4.4 비교 연산자와의 형변환 차이

앞서 언급된 비교 연산자가 들어간 표현식은 평가되어 불리언 값을 생성한다고 했다. 이는 제어문 또는 삼항 조건 연산자의 조건식, 논리 연산자의 표현식이 평가되어 불리언 값을 생성하는 것과 동일해보일 수 있다. 그러나 불리언 값을 생성하는 과정이 다르다. 다음 예제들을 살펴보자:

```jsx
// 동등 비교 연산자 
'' == false => Number('') == Number(false) => 0 == 0; // → true
'str' == true => Number('str') == Number(true) => NaN == 1; // → false
[] == 0 => Number([]) == 0 => 0 == 0; // → true
```

(일치 비교 연산자 `===`는 타입과 값이 모두 같은지 비교할 때만 사용한다) 동등 비교 연산자는 피연산자들이 다른 타입이어도 값이 같은지 비교해야 하기 때문에 숫자가 아닌 피연산자들을 숫자 타입으로 암묵적 타입 변환하여 비교 연산을 수행한다. 숫자 타입으로 암묵적 타입 변환이 불가능한 타입의 경우, 타입이 변환되지 않아 `NaN`이 되며 피연산자들의 동등 비교가 불가능하기 때문에 언제나 `false`가 반환된다

```jsx
// 대소 관계 비교 연산자
'' >= false => Number('') >= Number(false) => 0 >= 0; // → true
'str' > true => Number('str') > Number(true) => NaN > 1; // → false
[] >= 0 => Number([]) >= 0 => 0 >= 0; // → true
```

대소 관계 비교 연산자는 피연산자들의 크기를 비교해야 하기 때문에 숫자가 아닌 피연산자들을 숫자 타입으로 암묵적 타입 변환하여 비교 연산을 수행한다. 숫자 타입으로 암묵적 타입 변환이 불가능한 타입의 경우, 타입이 변환되지 않아 `NaN`이 되며 피연산자들의 대소 비교가 불가능하기 때문에 언제나 `false`가 반환된다

```jsx
// if 제어문 1
if ( '' ) {
	console.log('Truthy'); 
} else {
	console.log('Falsy'); // → Falsy
} 
// 위 제어문의 조건식이 평가되어 형변환되는 과정
'' => Boolean('') => Falsy => false

// if 제어문 2
if ('str') { 
	console.log('Truthy'); // → Truthy
} else {
	console.log('Falsy'); 
}
// 위 제어문의 조건식이 평가되어 형변환되는 과정
'str' => Boolean('str') => Truthy => true 

// 삼항 조건 연산자
var emptyStr = ''; 

var ternary = emptyStr ? 'Truthy' : 'Falsy'; 
console.log(ternary); // → Falsy
// 위 삼항 조건 연산자식의 조건식이 평가되어 형변환 되는 과정
emptyStr => Boolean('') => Falsy => false 

// 논리 연산자

'' || 'str'; // → 'str'
'' && 'str'; // → ''
!''; // → true
!!'str'; // → true
// 위 논리 연산자의 표현식이 평가되어 형변환되는 과정
'' => Boolean('') => Falsy => false
'str' => Boolean('str') => Truthy => true 
```

앞서 언급한대로 제어문 또는 삼항 조건 연산자, 논리 연산자에서 빈 문자열(`’’`)은 Falsy 값으로 분류된다. 문자열 `‘str’`은 Truthy 값으로 분류된다. 제어문 또는 삼항 조건 연산자의 경우, 위 조건식의 평가 및 분류 결과에 따라 불리언 타입으로 암묵적 타입 변환되어 각각의 블록문이 실행되는 것이다. 논리 연산자의 경우, 위 표현식의 평가 및 분류 결과에 따라 불리언 타입으로 암묵적 타입 변환되어 논리 연산을 수행하고 각각의 결과 값을 반환한다

그렇다면 숫자 타입 `0`과 문자열 타입 `‘0’`은 제어문에서 어떻게 형변환될까:

```jsx
// 비교 연산자
0 == false; // → true

// if 제어문 1
if ( 0 ) {
	console.log('Truthy');
} else { 
	console.log('Falsy'); // → Falsy
}; 	

// if 제어문 2
if ( '0' )  {
	console.log('Truthy'); // → Truthy
} else {
	console.log('Falsy'); 
};
```

숫자 타입 `0`은 제어문에서 Falsy 값으로 분류되어 `false`로 암묵적 타입 변환된다. 하지만 문자열 타입 `‘0’`은 빈 문자열(`’’`)이 아니기 때문에 제어문에서는 Truthy 값으로 분류되어 `true`로 암묵적 타입 변환된다.  따라서 `‘0’`이 들어간 조건식에 따라 `true`일 때의 블록문이 실행되는 것이다

추가로, 빈 배열(`[]`)의 형변환 과정도 살펴보자:

```jsx
// 비교 연산자
[] == 0; // → true
[] >= 0; // → true

// if 제어문
if ( [] ) {
	conosole.log('Truthy'); // → Truthy
} else {
	console.log('Falsy'); 
}
// 위 제어문의 조건식이 형변환되는 과정
[] => Boolean([]) => Truthy => true

// 삼항 조건 연산자
var emptyArr = []; 
var ternary = emptyArr ? 'Truthy' : 'Falsy'; 
console.log(ternary); // → Truthy
// 위 삼항 조건 연산자식의 조건식이 형변환되는 과정
emptyArr => Boolean([]) => Truthy => true  
```

“어? 빈 배열(`[]`)은 숫자 값 `0`으로 암묵적 타입 변환된다고 하지 않았나? `0`은 `false`로 암묵적 타입 변환되니까 `false`일 때의  코드 블록이 실행되어야 하는게 아닌가?”, “`[] == 0;`의 평가 결과는 `true`인데?”라고 헷갈릴 수 있다. 빈 배열(`[]`)이 숫자 값 `0`으로 암묵적 타입 변환되는 것은 비교 연산자 표현식이 평가될 때다

그렇다면 조건식이 비교 연산자 표현식인 경우는 어떨까?

```jsx
// 비교 연산자 표현식이자 조건식인 if 제어문
if ( '' == 1 ) {
	console.log('Truthy'); 
} else {
	console.log('Falsy'); // → Falsy
} 
// 위 조건식의 타입 변환되는 과정
'' == 1 => Number('') == 1 => 0 == 1 => false => Falsy => false
```

먼저 비교 연산자 표현식의 평가를 위한 과정과 동일하게, 비교 연산을 위해 숫자 타입이 아닌 피연산자는 숫자 타입으로 암묵적 타입 변환된다. 비교 연산자 표현식의 평가 결과는 불리언 타입 `false`다. 조건식의 평가 결과가 `false`이니, 앞서 언급한대로 `false`는 제어문에서 Falsy 값으로 분류되며 `false`로 암묵적 타입 변환된다

<br>

***

### 참고

- [모던 자바스크립트 Deep Dive](http://www.yes24.com/Product/Goods/92742567)